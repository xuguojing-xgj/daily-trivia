# 深拷贝和浅拷贝

## [浅拷贝](https://developer.mozilla.org/zh-CN/docs/Glossary/Shallow_copy)

    - 对象的浅拷贝是属性与拷贝的源对象属性共享相同的引用(指向相同的底层值)的副本, 因此,当你更改源对象或者副本时,也可能导致另一个对象发生更改, 与之相比, 在深拷贝中, 源对象和副本是完全独立的

    -   形式化地, 如果两个对象 o1 和 o2 是浅拷贝, 那么
        -  它们不是同一个对象 (o1 !== o2)
        -  o1 和 o2 的属性具有相同的名称且顺序相同
        -  它们的属性值相等
        -  它们的原型链相等

    -   所有属性都是原始值的对象的副本同时符合深拷贝和浅拷贝的定义
        -   讨论副本的深度我们通常在嵌套属性上下文中的深拷贝讨论
    -   对于浅拷贝,只有顶层属性被复制,而不是嵌套对象的值
        -   对象副本的顶层属性的重新赋值不会影响源对象
        -   对副本的嵌套对象属性的重新赋值会影响源对象

    -   在 JavaScript 中, 所有标准内置对象复制操作(扩展语法, Array.prototype.concat(), Array.prototype.slice(), Array.from() 和 Object.assign()) 都创建浅拷贝, 而不是深拷贝。

> 示例

```js
const obj = {
  a: 1,
  b: 2,
  c: {
    d: 3,
  },
  e: [() => {}, "string", true],
};

const clone = Object.assign({}, obj);
clone.a = 2;
clone.e[0] = "boolean"; // 影响源对象
console.log(obj);
console.log(clone.e);
console.log(clone.b === obj.b);
```

- 浅拷贝不会修改目标对象, 返回新的一组数据

## [深拷贝](https://developer.mozilla.org/zh-CN/docs/Glossary/Deep_copy)

    -   对象的深拷贝是指其属性与其拷贝的源对象的属性不共享相同的引用 (指向相同的底层值) 的副本
        -   在深拷贝更改源或副本时, 可以确保不会导致其他对象也发生更改
        -   但是在浅拷贝中, 对源或者副本的更改可能也会导致其他对象的更改 (因为两个对象共享相同的引用)

    -   如果两个对象 o1 和 o2 的结构等价的, 那么他们的观察行为是相同的, 这些行为包括:
        -   o1 和 o2 的属性具有相同的名称且顺序相同
        -   它们的属性的值是结构等价的
        -   它们的原型链是结构等价的 (尽管在处理结构等价时, 这些对象通常是普通对象, 意味着它们都继承自 object.prototype)

    -   结构等价的对象可以是同一个对象 (o1 === o2) 或者副本 (o1 !== o2)。因为等价的原始值总是相等的, 所以无法进行复制
    -   定义深拷贝
        -   它们不是同一个对象 (o1 !== o2)
        -   o1 和 o2 的属性具有相同的名称且顺序相同
        -   它们的属性的值是彼此的深拷贝
        -   它们的原型链是结构等价的
    -   深拷贝可能会或可能不会复制它们的原型链(通常情况下不会)。但是, 具有结构不等价原型链的两个对象 (例如, 一个是数组, 另一个是普通对象) 永远不会是彼此的副本

    -   所有属性都具有原始值的对象的副本符合深拷贝和浅拷贝的定义
        -   这种讨论的深度并无意义, 因为它没有嵌套属性,而我们通常在改变嵌套属性的上下文中讨论深拷贝
    -   如果一个 JS 对象可以被序列化, 则存在一种创建深拷贝的方式: 使用 `JSON.stringify()` 将该对象转化为 JSON 字符串, 然后使用 `JSON.parse()` 将该字符串转换回 (全新的) JS 对象

> 示例

```js
const arr = [
  "list",
  {
    a: 1,
    b: 2,
    c: {
      d: 3,
    },
    e: ["小红", "小明", "小紫"],
  },
];

const deep_clone = JSON.parse(JSON.stringify(arr));

deep_clone[0] = "map";
deep_clone[1].a = "string";
deep_clone[1].c.d = "true";
deep_clone[1].e = ["张三", "李四", "王五"];
console.log(arr);
console.log(deep_clone);
```

- 深拷贝与源对象不共享引用, 堆和栈的空间是独立的, 所以深拷贝的任何修改都不会影响到源对象
